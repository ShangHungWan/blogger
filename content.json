{"meta":{"title":"Sun 的學習筆記","subtitle":"Sun's note","description":"紀錄學習與開發過程的研究議題及技術文章","author":"Sun","url":"https://a24230928.github.io/blogger","root":"/blogger/"},"pages":[],"posts":[{"title":"Port_swigger_web_security_academy_sql_injection","slug":"port-swigger-web-security-academy-sql-injection","date":"2022-06-03T16:18:43.000Z","updated":"2022-06-03T17:24:10.144Z","comments":true,"path":"2022/06/04/port-swigger-web-security-academy-sql-injection/","link":"","permalink":"https://a24230928.github.io/blogger/2022/06/04/port-swigger-web-security-academy-sql-injection/","excerpt":"","text":"IntroductionThis article is the note of PortSwigger Web Security Academy’s SQL Injection. I will take note of it and write some my opinion. Examples Retrieving hidden data Subverting application logic UNION attack: retrieve data from other databases or tables. Examining the database Blind SQL injection Retrieving hidden dataFor example, there is a URL: 1https://insecure-website.com/products?category=Gifts and SQL like: 1SELECT * FROM products WHERE category = 'Gifts' AND released = 1 Thus, it can be injected by: 1https://insecure-website.com/products?category=' OR 1=1 -- This will results in the SQL query, and show every products: 1SELECT * FROM products WHERE category = '' OR 1=1 --' AND released = 1 Subverting application logicIt can bypass login or other business logic too. In case of SQL query like: 1SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese' We can login as administrator by input username administrator&#39; -- and left password blank, results in the SQL query: 1SELECT * FROM users WHERE username = 'administrator' --' AND password = '' UNION attackWe can use UNION to get other table’s data, for example: 1SELECT name, description FROM products WHERE category = '&#123;input&#125;' and we input: 1' UNION SELECT username, password FROM users -- result in query: 1SELECT name, description FROM products WHERE category = '' UNION SELECT username, password FROM users --' Then, we can get username and password from other table. Examining the databaseTo explot the database, we need to identify which database is it. Because every database have unique syntax, function, or variable…(there are some examples below), we can use some cheat table to determine it. database-specific factors Syntax for string concatenation Comments Batched or stacked queries Platform-specific APIs Error messages After we know what kind of database is it, we can grab some informations about databases, tables, and columns. For example, most database(MSSQL, MySQL, PostgreSQL…) have a database which store there information we need: 1SELECT * FROM information_schema.tables Blind SQL injectionWhen we can see the result of SQL query, we can use UNION to get the informations we need. But if the application does not return any results, we can still exploit it by following methods: Conditionally change the logic of the query to trigger a detectable difference. For example, trigger an error such as a divide-by-zero. Conditionally make a time delay. Trigger an out-of-band interaction sush as placing the data into a DNS lookup for a domain we control. How to detect vulnerabilitiesTo every entry point in the application, we can try: Submitting &#39; and looking for error or other abnormal response. Submitting some SQL-specific syntax or conditions such as OR 1=1 to change result of the query, and looking for differences in responses. For those cannot see response, submitting payload to trigger time delays and looking for differences in the time taken to respond. Second-order SQL InjectionFirst, we need to talk about First-order SQL injection. First-order means the application takes user’s input and use it to excute an SQL query. So, Second-order(that is, stored SQL injection) means the application store user’s input to database(or somewhere else). Later, the application retrieves the stored data and excute an SQL query with it. This will happen because developers are aware of SQL injection vulnerabilities, so safely handle the direct input from user. But they forgot that Second-order SQL query is also get input from user, so remember “DONT TRUST ANY USER INPUT” when you develop any application. How to preventSo after all, how do we prevent these vulnerabilites? We can use parameterized query(also known as prepared statements) instead of directly concatenate strings together. DONT USE: 1$query = \"SELECT * FROM products WHERE category = '\"+ $input + \"'\"; USE: 123$sql = \"SELECT * FROM products WHERE category = :category\";$sth = $dbh-&gt;prepare($sql, array(PDO::ATTR_CURSOR =&gt; PDO::CURSOR_FWDONLY));$sth-&gt;execute(array(':category' =&gt; 'shoes')); SummaryI think the most important lesson that SQLi bring us is “NEVER TRUST USER”. As a developer, we need to make sure we know the meaning of every single line of code that we are writting. And trust no one. References https://portswigger.net/web-security/sql-injection https://portswigger.net/web-security/sql-injection/cheat-sheet","categories":[],"tags":[{"name":"web security","slug":"web-security","permalink":"https://a24230928.github.io/blogger/tags/web-security/"},{"name":"sql injection","slug":"sql-injection","permalink":"https://a24230928.github.io/blogger/tags/sql-injection/"},{"name":"port swigger","slug":"port-swigger","permalink":"https://a24230928.github.io/blogger/tags/port-swigger/"}]},{"title":"EOS Jungle2.0 Testnet With Scatter Desktop","slug":"EOS-Jungle2-0-Testnet-with-Scatter-Desktop","date":"2020-05-11T01:38:04.000Z","updated":"2021-09-05T06:17:36.335Z","comments":true,"path":"2020/05/11/EOS-Jungle2-0-Testnet-with-Scatter-Desktop/","link":"","permalink":"https://a24230928.github.io/blogger/2020/05/11/EOS-Jungle2-0-Testnet-with-Scatter-Desktop/","excerpt":"","text":"此篇旨在紀錄筆者透過 Scatter 桌面版使用 Jungle2.0 Testnet的過程及教學 Generate key 打開Scatter，並點選 Wallet &gt; Generate Key 選擇 EOSIO 選擇 Key 此時 Scatter 即會幫你生成一個 Private Key，請自行保管好 按 Back 回到 Wallet的頁面 (步驟1.)，並將紅色框框中的 Public Key 複製下來 Create an account 點此註冊一個帳號 輸入 Account name，並將剛才的 Public Key 貼上在下面兩個欄位 Get Free Tokens 點此並輸入剛才的帳號名稱，就可以獲得 1 Token Add Jungle 2 Network in Scatter 回到 Scatter，並點選 Networks &gt; Add Custom Network Name 中輸入一個可辨識的名稱 Host 輸入 jungle2.cryptolions.io Protocol 為 https Port 為 443 Chain ID 為 e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473最後按下 Add 即可 Check Network Setting 最後回 Wallet 頁面，確認是否確實連上測試鏈。只要兩個紅框處分別呈現帳號名稱，及剛剛拿到的1個 Free Token，即為成功連結測試鏈。","categories":[],"tags":[]},{"title":"ERC-20 Token Standard 簡介","slug":"ERC-20-Token-Standard-簡介","date":"2020-05-11T01:33:25.000Z","updated":"2021-09-05T06:17:36.335Z","comments":true,"path":"2020/05/11/ERC-20-Token-Standard-簡介/","link":"","permalink":"https://a24230928.github.io/blogger/2020/05/11/ERC-20-Token-Standard-%E7%B0%A1%E4%BB%8B/","excerpt":"","text":"ERC-20 與 ERC-721 比較 簡單來說，ERC20是「每個代幣都一樣」；而ERC721則是「每個代幣都有其獨特性」 Interface1234567891011contract ERC20Interface &#123; function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#125; 總共有6個function以及2個event。其中constant的function是唯讀的，所以不會花費Gas。Event只用於記錄，可以視為一般系統上的log功能。 123string public constant name = \"Token Name\";string public constant symbol = \"SYM\";uint8 public constant decimals = 18; // 18 is the most common number of decimal places 另外還有三個需要設定的參數：name、symbol、decimals。name是Token的名字；symbol是Token的代稱（簡稱）；decimals是Token小數最多可以到幾位數，正常為18，也就是和Ether一樣。 Function 說明 totalSupply()，Token的發行總量。 balanceOf(address)，傳入地址的錢包的Token數量。 allowance(address A, address B)，A批准給B的Token量。 transfer(address A, uint num)，將數量為num的Token轉移給A。 approve(address A, uint num)，批准數量為num的Token轉移給A，需注意的是，這個function只是單純做「批准」這個動作，而沒有進行轉移。若需要轉移則要再呼叫transferFrom。 transferFrom(address, address, uint)，將數量為num的Token由A轉移給B。 注意事項Solidity版本 &gt;= 0.4.17 Ref. ERC20, ERC721比較 ERC-20標準doc","categories":[],"tags":[{"name":"ERC-20","slug":"ERC-20","permalink":"https://a24230928.github.io/blogger/tags/ERC-20/"},{"name":"ERC-721","slug":"ERC-721","permalink":"https://a24230928.github.io/blogger/tags/ERC-721/"},{"name":"Solidity","slug":"Solidity","permalink":"https://a24230928.github.io/blogger/tags/Solidity/"}]}],"categories":[],"tags":[{"name":"web security","slug":"web-security","permalink":"https://a24230928.github.io/blogger/tags/web-security/"},{"name":"sql injection","slug":"sql-injection","permalink":"https://a24230928.github.io/blogger/tags/sql-injection/"},{"name":"port swigger","slug":"port-swigger","permalink":"https://a24230928.github.io/blogger/tags/port-swigger/"},{"name":"ERC-20","slug":"ERC-20","permalink":"https://a24230928.github.io/blogger/tags/ERC-20/"},{"name":"ERC-721","slug":"ERC-721","permalink":"https://a24230928.github.io/blogger/tags/ERC-721/"},{"name":"Solidity","slug":"Solidity","permalink":"https://a24230928.github.io/blogger/tags/Solidity/"}]}